<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[从递归说起]]></title>
      <url>/javascript/2019/05/09/%E4%BB%8E%E9%80%92%E5%BD%92%E8%AF%B4%E8%B5%B7/</url>
      <content type="text"><![CDATA[什么是递归语言例子从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚…”google 解释简单定义函数调用自身，称为递归。斐波那契数列  斐波那契数列从第三项开始，每一项都等于前两项之和。指的是这样一个数列：0, 1, 1, 2, 3, 5, 8 …function fib(n) {	if (n === 1 || n === 2) return n - 1;	return fib(n - 1) + fib(n - 2);}console.log(fib(20));一切能用递归写的函数，都能用循环写——尼克拉斯·夏function fib(n) {	let a = 0;	let b = 1;	let c = a + b;	for (let i = 3; i &lt; n; i++) {		a = b;		b = c;		c = a + b;	}	return c;}console.log(fib(20));性能问题？调用栈（Call Stack）栈帧  栈帧是指为一个函数调用单独分配的那部分栈空间当运行的程序从当前函数调用另外一个函数时，就会为下一个函数建立一个新的栈帧，并且进入这个栈帧，这个栈帧称为当前帧。而原来的函数也有一个对应的栈帧，被称为调用帧。每一个栈帧里面都会存入当前函数的局部变量。调用栈  当函数被调用时，就会被加入到调用栈顶部，执行结束之后，就会从调用栈顶部移除该函数。并将程序运行权利（帧指针）交给此时栈顶的栈帧。这种后进先出的结构也就是函数的调用栈e.g.function a() {	b();}function b() {	c();}function c() {	console.trace();}a();js 引擎如何工作的？js 执行过程相关概念：      EC: 执行上下文        ECS: 执行上下文栈        VO： 变量对象        AO： 活动对象        scope chain：作用域链  EC: 执行上下文js 的三种运行环境  全局代码：代码默认运行的环境，最先会进入到全局环境中  函数代码：在函数的局部环境中运行的代码  Eval 代码：在 Eval()函数中运行的代码全局上下文是最外围的一个执行环境，web 浏览器中被认为是 window 对象。在初始化代码时会先进入全局上下文中，每当一个函数被调用时就会为该函数创建一个执行上下文，每个函数都有自己的执行上下文e.g.function f1() {	var f1Context = "f1 context";	function f2() {		var f2Context = "f2 context";		function f3() {			var f3Context = "f3 context";			console.log(f3Context);		}		f3();		console.log(f2Context);	}	f2();	console.log(f1Context);}f1();这段代码有 4 个执行上下文：全局上下文和 f1()，f2()，f3()属于自己的执行上下文。全局上下文拥有变量 f1()，f1()的上下文中有变量 f1Context 和 f2()，f2()的上下文有变量 f2Context 和 f3()，f3()上下文有变量 f3Context。ECS(执行上下文栈)一段代码所有的执行上下文都会被推入栈中等待被执行，因为 js 是单线程（渲染进程有哪些线程？)，任务都为同步任务的情况下某一时间只能执行一个任务，执行一段代码首先会进入全局上下文中，并将其压入 ECS 中，执行 f1()会为其创建执行上下文压入栈顶，f1()中有 f2()，再为 f2()创建 f2()的执行上下文，依次，最终全局上下文被压入到栈底，f3()的执行上下文在栈顶，函数执行完后，ECS 就会弹出其上下文，f3()上下文弹出后，f2()上下文来到栈顶，开始执行 f2()，依次，最后 ECS 中只剩下全局上下文，它等到应用程序退出，例如浏览器关闭时销毁。小结      全局上下文压入栈顶        执行某一函数就为其创建一个 EC，并压入栈顶        栈顶的函数执行完之后它的 EC 就会从 ECS 中弹出，并且变量对象(VO)随之销毁        所有函数执行完之后 ECS 中只剩下全局上下文，在应用关闭时销毁  以下代码的输出？ 过程？function foo(i) {	if (i == 3) {		return;	}	foo(i + 1);	console.log(i);	console.trace();}foo(0);VO(变量对象)  创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。AO(活动对象)  进入到一个执行上下文时，此执行上下文中的变量和函数都可以被访问到，可以理解为被激活EC 建立的过程建立阶段：(函数被调用，但是还未执行函数中的代码)	1. 创建变量，参数，函数，arguments对象（创建变量环境组件）	2. 建立scope chain(作用域链)（创建词法环境组件）	3. 确定this的值执行阶段：变量赋值，函数引用，执行代码执行上下文为一个对象，包含 VO，作用域链和 thisexecutionContextObj = {	variableObject: { /* 函数中的arguments对象, 参数, 内部的变量以及函数声明 */ },	scopeChain: { /* variableObject 以及所有父执行上下文中的variableObject */ },	this: {}}详细过程1. 找到当前上下文调用函数的代码2. 执行代码之前，先创建执行上下文3. 创建阶段：	3-1. 创建变量对象(VO)：		1. 创建arguments对象，检查当前上下文的参数，建立该对象下的属性和属性值		2. 扫描上下文的函数申明：			1. 每扫描到一个函数什么就会在VO里面用函数名创建一个属性，为一个指针，指向该函数在内存中的地址			2. 如果函数名在VO中已经存在，对应的属性值会被新的引用覆盖		3. 扫描上下文的变量申明：			1. 每扫描到一个变量就会用变量名作为属性名，其值初始化为undefined			2. 如果该变量名在VO中已经存在，则直接跳过继续扫描	3-2. 初始化作用域链	3-3. 确定上下文中this的指向4. 代码执行阶段	4-1. 执行函数体中的代码，给VO中的变量赋值变量提升在哪一个阶段？scope chain(作用域链)  当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链js 是基于词法作用域的，这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中e.g.function foo() {	function bar() {}}函数创建时，各自的[[scope]]为:foo.[[scope]] = [  globalContext.VO];bar.[[scope]] = [    fooContext.AO,    globalContext.VO];当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端Scope = [AO].concat([[Scope]]);作用域链创建完毕词法环境  一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成词法环境的内部有两个组件：环境记录器：存储变量和函数声明的实际位置。外部环境的引用：可以访问其父级词法环境（作用域）e.g.var scope = "global scope";function checkscope() {	var scope2 = "local scope";	return scope2;}checkscope();执行过程如下：1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]]checkscope.[[scope]] = [  globalContext.VO];2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈ECStack = [	checkscopeContext,	globalContext];3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链checkscopeContext = {	Scope: checkscope.[[scope]],}4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明checkscopeContext = {	AO: {		arguments: {				length: 0		},		scope2: undefined	}，	Scope: checkscope.[[scope]],}5.第三步：将活动对象压入 checkscope 作用域链顶端checkscopeContext = {	AO: {			arguments: {					length: 0			},			scope2: undefined	},	Scope: [AO, [[Scope]]]}6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值checkscopeContext = {	AO: {		arguments: {				length: 0		},		scope2: 'local scope'	},	Scope: [AO, [[Scope]]]}7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出ECStack = [	globalContext];thisECMAScript 的类型分为语言类型和规范类型。ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的 Undefined, Null, Boolean, String, Number, 和 Object。而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record，只存在于规范里的抽象类型，它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中this 的指向与 Reference 类型有着密切的关联（以后再讲）gc 机制？总结1. 调用函数时会为其创建执行上下文，并压入执行环境栈的栈顶，执行完毕弹出，执行上下文被销毁，随之VO也被销毁2. EC创建阶段分创建阶段和代码执行阶段3. 创建阶段初始变量值为undefined，执行阶段才为变量赋值4. 函数申明先于变量申明再次理解调用栈？尾调用什么是尾调用  函数执行的最后一步是将另外一个函数调用并返回function f(x) {  if (x &gt; 0) {    return m(x)  }  return n(x);}function f(x){  let y = g(x);  return y;}function f(x){  return g(x);}function f(x){  return g(x) + 1;}function f(x) {  g(x);}function f() {	let m = 1;	let n = 2;	return g(m + n);}const a = () =&gt; f() || g();尾调用优化在调用栈的部分我们知道，当一个函数 A 调用另外一个函数 B 时，就会形成栈帧，在调用栈内同时存在调用帧 A 和当前帧 B，这是因为当函数 B 执行完成后，还需要将执行权返回 A，那么函数 A 内部的变量，调用函数 B 的位置等信息都必须保存在调用帧 A 中。不然，当函数 B 执行完继续执行函数 A 时，就 xx 了。那么现在，我们将函数 B 放到了函数 A 的最后一步调用（即尾调用），那还有必要保留函数 A 的栈帧么？当然不用，因为之后并不会再用到其调用位置、内部变量。因此直接用函数 B 的栈帧取代 A 的栈帧即可。当然，如果内层函数使用了外层函数的变量，那么就仍然需要保留函数 A 的栈帧，典型例子即是闭包。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了  只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。再次理解递归？尾递归  函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”stack overflow”错误（n 个调用记录，复杂度 O(n)）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”stack overflow”错误（只保留一个调用记录，复杂度 O(1)）。阶乘递归函数的改写改写前function factorial(n) {	if (n === 1) return 1;	return n * factorial(n - 1);}factorial(5);改写后function factorial(n, total) {	if (n === 1) return total;	return factorial(n - 1, n * total);}factorial(5, 1);需要传入两个参数？方法一：es6 的函数默认值function factorial(n, total = 1) {  if (n === 1) return total;  return factorial(n - 1, n * total);}factorial(5)斐波那契数列的改写function fTail(n, a = 0, b = 1) {	console.trace();	if (n === 0) return a;	return fTail(n - 1, b, a + b);}console.log(fTail(10));方法二：在尾递归函数之外，再提供一个正常形式的函数function tailFactorial(n, total) {	if (n === 1) return total;	return tailFactorial(n - 1, n * total);}function factorial(n) {	return tailFactorial(n, 1);}factorial(5);多参变单参？柯里化  把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术function currying(fn, n) {	return function(m) {		return fn.call(this, m, n);	};}function tailFactorial(n, total) {	if (n === 1) return total;	return tailFactorial(n - 1, n * total);}const factorial = currying(tailFactorial, 1);factorial(5);多参数函数转换为接收单一参数的函数function fe(a, b, c) {	return a + b + c;}function curry(fe) {	let args = []; // 参数集合	let len = args.length;	return function bar() {		args = [...args, ...arguments]; // 收集参数		if (args.length &gt;= fe.length) {			return fe.apply(this, args);		}		return bar;	};}console.log(curry(fe)(1)(2)(3));纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现还有一个问题？严格模式尾调用优化只在严格模式下开启在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈  fn.arguments：表示对 fn 最近一次调用所包含的参数。  fn.caller：引用对 fn 最近一次调用的那个函数es6 严格模式  变量必须声明后再使用  函数的参数不能有同名属性，否则报错  不能使用 with 语句  不能对只读属性赋值，否则报错  不能使用前缀 0 表示八进制数，否则报错  不能删除不可删除的属性，否则报错  不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]  eval 不会在它的外层作用域引入变量  eval 和 arguments 不能被重新赋值  arguments 不会自动反映函数参数的变化  不能使用 arguments.callee  不能使用 arguments.caller  禁止 this 指向全局对象  不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈  增加了保留字（比如 protected、static 和 interface）测试chrome 未开启  在引擎层面消除尾递归是一个隐式的行为，程序员写代码时可能意识不到自己写了死循环的尾递归，而出现死循环后又不会报出 stack overflow 的错误，难以辨别。  堆栈信息会在优化的过程中丢失，开发者调试非常困难node（6.1.0）  node –harmony_tailcalls test.jsnode 测试结果未开启：node 测试结果开启：感谢您的阅读]]></content>
      <categories>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
