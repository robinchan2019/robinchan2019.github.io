---
title: 从递归说起
description: 从递归出发，对js基础知识的发散
categories:
 - javascript
tags:
---

<!-- more -->

---

## 什么是递归

---

#### 语言例子

从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚...”

#### google 解释

![google 解释](/assets/images/posts/recursive-google.jpg)

#### 简单定义

函数**调用**自身，称为递归。

#### 斐波那契数列

> 斐波那契数列从第三项开始，每一项都等于前两项之和。指的是这样一个数列：0, 1, 1, 2, 3, 5, 8 …

```js
function fib(n) {
	if (n === 1 || n === 2) return n - 1;
	return fib(n - 1) + fib(n - 2);
}
console.log(fib(20));
```

#### 所有的递归都可以改成循环

```js
function fib(n) {
	let a = 0;
	let b = 1;
	let c = a + b;
	for (let i = 3; i < n; i++) {
		a = b;
		b = c;
		c = a + b;
	}
	return c;
}
console.log(fib(20));
```

#### 性能问题？

---

## 调用栈（Call Stack）

---

#### 栈帧

> 栈帧是指为一个函数调用单独分配的那部分栈空间

当运行的程序从当前函数调用另外一个函数时，就会为下一个函数建立一个新的栈帧，并且进入这个栈帧，这个栈帧称为当前帧。而原来的函数也有一个对应的栈帧，被称为调用帧。每一个栈帧里面都会存入当前函数的局部变量。

![栈帧结构示意图](/assets/images/posts/stack-frame.jpg)

#### 调用栈

> 当函数被调用时，就会被加入到调用栈顶部，执行结束之后，就会从调用栈顶部移除该函数。并将程序运行权利（帧指针）交给此时栈顶的栈帧。这种后进后出的结构也就是函数的调用栈

#### e.g.

```js
function a() {
	b();
}

function b() {
	c();
}

function c() {
	console.trace();
}

a();
```

![看当前函数调用栈](/assets/images/posts/e.g.1.jpg)

#### js 引擎如何工作的？

---

## js 执行过程

---

#### 相关概念：

- EC: 执行上下文

- ECS: 执行上下文栈

- VO： 变量对象

- AO： 活动对象

- scope chain：作用域链

#### EC: 执行上下文

#### javascript 运行的代码环境有三种：

> 全局代码：代码默认运行的环境，最先会进入到全局环境中

> 函数代码：在函数的局部环境中运行的代码

> Eval 代码：在 Eval()函数中运行的代码

全局上下文是最外围的一个执行环境，web 浏览器中被认为是 window 对象。在初始化代码时会先进入全局上下文中，每当一个函数被调用时就会为该函数创建一个执行上下文，每个函数都有自己的执行上下文

#### e.g.

```js
function f1() {
	var f1Context = "f1 context";
	function f2() {
		var f2Context = "f2 context";
		function f3() {
			var f3Context = "f3 context";
			console.log(f3Context);
		}
		f3();
		console.log(f2Context);
	}
	f2();
	console.log(f1Context);
}
f1();
```

这段代码有 4 个执行上下文：全局上下文和 f1()，f2()，f3()属于自己的执行上下文。

全局上下文拥有变量 f1()，f1()的上下文中有变量 f1Context 和 f2()，f2()的上下文有变量 f2Context 和 f3()，f3()上下文有变量 f3Context。

#### ECS(执行上下文栈)

一段代码所有的执行上下文都会被推入栈中等待被执行，因为 js 是单线程（**渲染进程有哪些线程？**)，任务都为同步任务的情况下某一时间只能执行一个任务，执行一段代码首先会进入全局上下文中，并将其压入 ECS 中，执行 f1()会为其创建执行上下文压入栈顶，f1()中有 f2()，再为 f2()创建 f2()的执行上下文，依次，最终全局上下文被压入到栈底，f3()的执行上下文在栈顶，函数执行完后，ECS 就会弹出其上下文，f3()上下文弹出后，f2()上下文来到栈顶，开始执行 f2()，依次，最后 ECS 中只剩下全局上下文，它等到应用程序退出，例如浏览器关闭时销毁。

![执行上下文栈](/assets/images/posts/ec.jpg)

#### 小结

1. 全局上下文压入栈顶

2. 执行某一函数就为其创建一个 EC，并压入栈顶

3. 栈顶的函数执行完之后它的 EC 就会从 ECS 中弹出，并且变量对象(VO)随之销毁

4. 所有函数执行完之后 ECS 中只剩下全局上下文，在应用关闭时销毁

#### 输出？过程？

```js
function foo(i) {
	if (i == 3) {
		return;
	}
	foo(i + 1);
	console.log(i);
	console.trace();
}
foo(0);
```

#### VO(变量对象)

> 创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。

#### AO(活动对象)

> 进入到一个执行上下文时，此执行上下文中的变量和函数都可以被访问到，可以理解为被激活

#### EC 建立的过程

```
建立阶段：(函数被调用，但是还未执行函数中的代码)
	1. 创建变量，参数，函数，arguments对象
	2. 建立scope chain(作用域链)
	3. 确定this的值

执行阶段：变量赋值，函数引用，执行代码
```

执行上下文为一个对象，包含 VO，作用域链和 this

```
executionContextObj = {
	variableObject: { /* 函数中的arguments对象, 参数, 内部的变量以及函数声明 */ },
	scopeChain: { /* variableObject 以及所有父执行上下文中的variableObject */ },
	this: {}
}
```

#### 详细过程

```
1. 找到当前上下文调用函数的代码

2. 执行代码之前，先创建执行上下文

3. 创建阶段：

	3-1. 创建变量对象(VO)：

		1. 创建arguments对象，检查当前上下文的参数，建立该对象下的属性和属性值

		2. 扫描上下文的函数申明：

			1. 每扫描到一个函数什么就会在VO里面用函数名创建一个属性，为一个指针，指向该函数在内存中的地址

			2. 如果函数名在VO中已经存在，对应的属性值会被新的引用覆盖

		3. 扫描上下文的变量申明：

			1. 每扫描到一个变量就会用变量名作为属性名，其值初始化为undefined

			2. 如果该变量名在VO中已经存在，则直接跳过继续扫描

	3-2. 初始化作用域链

	3-3. 确定上下文中this的指向

4. 代码执行阶段

	4-1. 执行函数体中的代码，给VO中的变量赋值
```

#### 变量提升在哪一个阶段？

#### scope chain(作用域链)

```js
var scope = "global scope";
function checkscope() {
	var scope2 = "local scope";
	return scope2;
}
checkscope();
```

执行过程如下：

1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]]

```js
checkscope.[[scope]] = [
  globalContext.VO
];
```

2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈

```
ECStack = [
	checkscopeContext,
	globalContext
];
```

3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链

```
checkscopeContext = {
	Scope: checkscope.[[scope]],
}
```

4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明

```
checkscopeContext = {
	AO: {
		arguments: {
				length: 0
		},
		scope2: undefined
	}，
	Scope: checkscope.[[scope]],
}
```

5.第三步：将活动对象压入 checkscope 作用域链顶端

```
checkscopeContext = {
	AO: {
			arguments: {
					length: 0
			},
			scope2: undefined
	},
	Scope: [AO, [[Scope]]]
}
```

6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值

```
checkscopeContext = {
	AO: {
		arguments: {
				length: 0
		},
		scope2: 'local scope'
	},
	Scope: [AO, [[Scope]]]
}
```

7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出

```
ECStack = [
	globalContext
];
```

#### this

ECMAScript 的类型分为语言类型和规范类型。

ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的 Undefined, Null, Boolean, String, Number, 和 Object。

而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record

this 的指向与 Reference 类型有着密切的关联（以后再讲）

#### gc 机制？

#### 总结

```
1. 调用函数时会为其创建执行上下文，并压入执行环境栈的栈顶，执行完毕弹出，执行上下文被销毁，随之VO也被销毁

2. EC创建阶段分创建阶段和代码执行阶段

3. 创建阶段初始变量值为undefined，执行阶段才为变量赋值

4. 函数申明先于变量申明
```

#### 了解了 js 的执行过程， 再次理解调用栈？

---

## 尾调用

---

#### 什么是尾调用

> 函数执行的最后一步是将另外一个函数调用并返回

```

function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}


function f(x){
  let y = g(x);
  return y;
}


function f(x){
  return g(x) + 1;
}


function f(x) {
  g(x);
}

function f(x){
  return g(x);
}

```

#### 尾调用优化

在调用栈的部分我们知道，当一个函数 A 调用另外一个函数 B 时，就会形成栈帧，在调用栈内同时存在调用帧 A 和当前帧 B，这是因为当函数 B 执行完成后，还需要将执行权返回 A，那么函数 A 内部的变量，调用函数 B 的位置等信息都必须保存在调用帧 A 中。不然，当函数 B 执行完继续执行函数 A 时，就乱了。

那么现在，我们将函数 B 放到了函数 A 的最后一步调用（即尾调用），那还有必要保留函数 A 的栈帧么？当然不用，因为之后并不会再用到其调用位置、内部变量。因此直接用函数 B 的栈帧取代 A 的栈帧即可。当然，如果内层函数使用了外层函数的变量，那么就仍然需要保留函数 A 的栈帧，典型例子即是闭包。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了

> 只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。

#### 再次理解递归？

---

## 尾递归

---

> 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生"stack overflow"错误（n 个调用记录，复杂度 O(n)）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"stack overflow"错误（只保留一个调用记录，复杂度 O(1)）。

#### 阶乘递归函数的改写

改写前

```js
function factorial(n) {
	if (n === 1) return 1;
	return n * factorial(n - 1);
}

factorial(5);
```

改写后

```js
function factorial(n, total) {
	if (n === 1) return total;
	return factorial(n - 1, n * total);
}

factorial(5, 1);
```

#### 需要传入两个参数？

_方法一：es6 的函数默认值_

```
function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5)
```

#### 斐波那契数列的改写

```js
function fTail(n, a = 0, b = 1) {
	console.trace();
	if (n === 0) return a;
	return fTail(n - 1, b, a + b);
}

console.log(fTail(10));
```

_方法二：在尾递归函数之外，再提供一个正常形式的函数_

```js
function tailFactorial(n, total) {
	if (n === 1) return total;
	return tailFactorial(n - 1, n * total);
}

function factorial(n) {
	return tailFactorial(n, 1);
}

factorial(5);
```

#### 多参变单参？

---

## 柯里化

---

> 把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术

```js
function currying(fn, n) {
	return function(m) {
		return fn.call(this, m, n);
	};
}

function tailFactorial(n, total) {
	if (n === 1) return total;
	return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5);
```

#### 多参数函数转换为接收单一参数的函数

```js
function fe(a, b, c) {
	return a + b + c;
}

function curry(fe) {
	let args = []; // 参数集合
	let len = args.length;
	return function bar() {
		args = [...args, ...arguments]; // 收集参数
		if (args.length >= fe.length) {
			return fe.apply(this, args);
		}
		return bar;
	};
}

console.log(curry(fe)(1)(2)(3));
```

_纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现_

#### 还有一个问题？

---

## 严格模式

---

在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈

- arguments：返回调用时函数的参数。
- func.caller：返回调用当前函数的那个函数

#### es6 严格模式

1. 变量必须声明后再使用
2. 函数的参数不能有同名属性，否则报错
3. 不能使用 with 语句
4. 不能对只读属性赋值，否则报错
5. 不能使用前缀 0 表示八进制数，否则报错
6. 不能删除不可删除的属性，否则报错
7. 不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]
8. eval 不会在它的外层作用域引入变量
9. eval 和 arguments 不能被重新赋值
10. arguments 不会自动反映函数参数的变化
11. 不能使用 arguments.callee
12. 不能使用 arguments.caller
13. 禁止 this 指向全局对象
14. 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈
15. 增加了保留字（比如 protected、static 和 interface）

---

## 测试

---

[chrome 未开启](https://github.com/v8/v8.dev/blob/master/src/blog/modern-javascript.md)

- 在引擎层面消除尾递归是一个隐式的行为，程序员写代码时可能意识不到自己写了死循环的尾递归，而出现死循环后又不会报出 stack overflow 的错误，难以辨别。
- 堆栈信息会在优化的过程中丢失，开发者调试非常困难

#### node（6.1.0）

> node --harmony_tailcalls test.js

node 测试结果未开启：

![node 测试结果未开启](/assets/images/posts/node-test-no.jpg)

node 测试结果开启：

![node 测试结果开启](/assets/images/posts/node-test-yes.jpg)

---

_感谢您的阅读_

---
